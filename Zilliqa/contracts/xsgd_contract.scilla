scilla_version 0

import BoolUtils IntUtils ListUtils

library XSGDContract

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end
let andb_3 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) =>
    let t = andb a b in
    andb c t
let andb_4 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) =>
    let t = andb_3 a b c in
    andb d t
let andb_5 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) => fun (e : Bool) =>
    let t = andb_4 a b c d in
    andb e t
let andb_6 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) => fun (e : Bool) => fun (f : Bool) =>
    let t = andb_5 a b c d e in
    andb f t  
let orb_3 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) =>
    let t = orb a b in
    orb c t
let orb_4 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) =>
    let t = orb_3 a b c in
    orb t d
let orb_5 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) => fun (e : Bool) =>
    let t = orb_4 a b c d in
    orb t e
let orb_6 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) => fun (e : Bool) => fun (f : Bool) =>
    let t = orb_5 a b c d e in
    orb t f
let one_msg =
    fun (msg : Message) =>
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg
let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp
let zero = Uint128 0
let one  = Uint128 1
let none_uint128 = None {Uint128}
let true = True
let false = False
let null_address = 0x0000000000000000000000000000000000000000
(* Error events *)
type Error =
  | CodeNotProxy
  | CodeNotOwner
  | CodeNotPauser
  | CodeNotBlacklister
  | CodeNotMasterMinter
  | CodeNotMinter
  | CodeIsNull
  | CodeIsSelf
  | CodeInsufficientMintAllowance
  | CodeNoMintAllowance
  | CodeNotAuthorized
  | CodeNotFound
  | CodeInsufficientFunds
  | CodeInsufficientAllowance
  | CodeIsPaused
  | CodeNotPaused
  | CodeIsBlacklisted
  | CodeNotBlacklisted
let make_error_event =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotProxy                  => Int32 -1
      | CodeNotOwner                  => Int32 -2
      | CodeNotPauser                 => Int32 -3
      | CodeNotBlacklister            => Int32 -4
      | CodeNotMasterMinter           => Int32 -5
      | CodeNotMinter                 => Int32 -6
      | CodeIsNull                    => Int32 -7
      | CodeIsSelf                    => Int32 -8
      | CodeInsufficientMintAllowance => Int32 -9
      | CodeNoMintAllowance           => Int32 -10
      | CodeNotAuthorized             => Int32 -11
      | CodeNotFound                  => Int32 -12
      | CodeInsufficientFunds         => Int32 -13
      | CodeInsufficientAllowance     => Int32 -14
      | CodeIsPaused                  => Int32 -15
      | CodeNotPaused                 => Int32 -16
      | CodeIsBlacklisted             => Int32 -16
      | CodeNotBlacklisted            => Int32 -16
      end
    in
    { _eventname : "Error"; code : result_code }

contract XSGDContract
(
  name :    String,
  symbol :  String,
  decimals : Uint32,
  init_owner : ByStr20,
  proxy_address : ByStr20
)
with
  let string_is_not_empty =
    fun (s : String) =>
      let zero = Uint32 0 in
      let s_length = builtin strlen s in
      let s_empty = builtin eq s_length zero in
      negb s_empty
  in
  let name_ok = string_is_not_empty name in
  let symbol_ok = string_is_not_empty symbol in
  let name_symbol_ok = andb name_ok symbol_ok in
  let decimals_ok =
    let six = Uint32 6 in
    let eighteen = Uint32 18 in
    let decimals_at_least_6 = uint32_le six decimals in
    let decimals_no_more_than_18 = uint32_le decimals eighteen in
    andb decimals_at_least_6 decimals_no_more_than_18 in
  andb name_symbol_ok decimals_ok
=>

field owner : ByStr20 = init_owner
field pauser : ByStr20 = init_owner
field masterMinter : ByStr20 = init_owner
field paused : Bool = True
field blacklister : ByStr20 = init_owner
field blacklisted : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field minterAllowed : Map ByStr20 (Option Uint128) = Emp ByStr20 (Option Uint128)

procedure ThrowError(err : Error)
  e = make_error_event err;
  event e;
  throw
end

procedure isProxy(address: ByStr20)
  is_proxy = builtin eq proxy_address address;
  match is_proxy with
  | True =>
  | False =>
    err = CodeNotProxy;
    ThrowError err
  end
end

procedure isOwner(address: ByStr20)
  current_owner <- owner;
  is_owner = builtin eq current_owner address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure isPauser(address: ByStr20)
  current_pauser <- pauser;
  is_pauser = builtin eq current_pauser address;
  match is_pauser with
  | True  =>
  | False =>
    err = CodeNotPauser;
    ThrowError err
  end
end

procedure isPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
  | False =>
    err = CodeNotPaused;
    ThrowError err
  end
end

procedure isNotPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
    err = CodeIsPaused;
    ThrowError err
  | False =>
  end
end

procedure isBlacklister(address: ByStr20)
  current_blacklister <- blacklister;
  is_blacklister = builtin eq current_blacklister address;
  match is_blacklister with
  | True  =>
  | False =>
    err = CodeNotBlacklister;
    ThrowError err
  end
end

procedure isBlacklisted(address: ByStr20)
  is_blacklisted <- exists blacklisted[address];
  match is_blacklisted with
  | True =>
  | False =>
    err = CodeNotBlacklisted;
    ThrowError err
  end
end

procedure isNotBlacklisted(address: ByStr20)
  is_blacklisted <- exists blacklisted[address];
  match is_blacklisted with
  | True =>
    err = CodeIsBlacklisted;
    ThrowError err
  | False =>
  end
end

procedure isMasterMinter(address: ByStr20)
  current_masterMinter <- masterMinter;
  is_masterMinter = builtin eq current_masterMinter address;
  match is_masterMinter with
  | True  =>
  | False =>
    err = CodeNotMasterMinter;
    ThrowError err
  end
end

procedure isMinter(address: ByStr20)
  is_minter <- minterAllowed[address];
  match is_minter with
  | Some (Some allowance)  =>
  | _ =>
    err = CodeNotMinter;
    ThrowError err
  end
end

procedure isNotNull(address: ByStr20)
  is_null = builtin eq null_address address;
  match is_null with
  | True =>
    err = CodeIsNull;
    ThrowError err
  | False =>
  end
end

procedure isNotSelf(a: ByStr20, b: ByStr20)
  is_not_self = builtin eq a b;
  match is_not_self with
  | True =>
    err = CodeIsSelf;
    ThrowError err
  | False =>
  end
end

transition transferOwnership(newOwner : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isOwner initiator;
  isNotNull newOwner;
  owner := newOwner;
  e = {_eventname : "OwnershipTransferred"; from : initiator; to : newOwner};
  event e
end

transition pause(initiator : ByStr20)
  isProxy _sender;
  isPauser initiator;
  paused := true;
  e = { _eventname : "Paused"; sender : initiator};
  event e
end

transition unpause(initiator : ByStr20)
  isProxy _sender;
  isPauser initiator;
  paused := false;
  e = {_eventname : "Unpaused"; sender : initiator};
  event e
end

transition updatePauser(newPauser : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isOwner initiator;
  isNotNull newPauser;
  current_pauser <- pauser;
  isNotSelf current_pauser newPauser;
  pauser := newPauser;
  e = {_eventname : "PauserUpdated"; pauser : newPauser; sender : initiator};
  event e
end

transition blacklist(address : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isBlacklister initiator;
  isNotNull address;
  isNotBlacklisted address;
  blacklisted[address] := one;
  e = {_eventname : "Blacklisted"; address : address; sender : initiator};
  event e
end

transition unBlacklist(address : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isBlacklister initiator;
  isNotNull address;
  isBlacklisted address;
  delete blacklisted[address];
  e = {_eventname : "UnBlacklisted"; address : address; sender : initiator};
  event e
end

transition updateBlacklister(newBlacklister : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isOwner initiator;
  isNotNull newBlacklister;
  current_blacklister <- blacklister;
  isNotSelf current_blacklister newBlacklister;
  blacklister:= newBlacklister;
  e = {_eventname : "BlacklisterUpdated"; blacklister : newBlacklister; sender : initiator};
  event e
end

transition updateMasterMinter(newMasterMinter : ByStr20, initiator : ByStr20)
  isProxy _sender;
  isOwner initiator;
  isNotNull newMasterMinter;
  current_masterMinter <- masterMinter;
  isNotSelf current_masterMinter newMasterMinter;
  masterMinter := newMasterMinter;
  e = {_eventname : "MasterMinterUpdated"; masterMinter : newMasterMinter; sender : initiator};
  event e
end

transition increaseMinterAllowance(minter : ByStr20, amount : Uint128, initiator : ByStr20)
  isProxy _sender;
  isMasterMinter initiator;
  isNotNull minter;
  get_minter_allowance <- minterAllowed[minter];
  mint_allowance =
    match get_minter_allowance with
    | Some (Some allowance) => allowance
    | _ => zero
    end;
  new_mint_allowance = builtin add mint_allowance amount;
  new_option_mint_allowance = Some {Uint128} new_mint_allowance;
  minterAllowed[minter] := new_option_mint_allowance;
  e = { _eventname : "IncreasedMinterAllowance"; minter : minter; new_mint_allowance : new_mint_allowance; sender : initiator};
  event e
end

transition decreaseMinterAllowance(minter : ByStr20, amount : Uint128, initiator : ByStr20)
  isProxy _sender;
  isMasterMinter initiator;
  isNotNull minter;
  get_minter_allowance <- minterAllowed[minter];
  mint_allowance =
    match get_minter_allowance with
    | Some (Some allowance) => allowance
    | _ => zero
    end;
  new_option_mint_allowance =
    let amount_le_allowance = uint128_le amount mint_allowance in
    match amount_le_allowance with
    | True =>
        let new_mint_allowance = builtin sub mint_allowance amount in
        let is_zero = builtin eq new_mint_allowance zero in
        match is_zero with
        | True => None {Uint128}
        | False => Some {Uint128} new_mint_allowance
        end
    | False => None {Uint128}
    end;
  minterAllowed[minter] := new_option_mint_allowance;
  e = { _eventname : "DecreasedMinterAllowance"; minter : minter; new_option_mint_allowance : new_option_mint_allowance; sender : initiator};
  event e
end

transition mint(to: ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, current_supply : Uint128)
  isProxy _sender;
  isNotPaused;
  isMinter initiator;
  isNotBlacklisted initiator;
  isNotBlacklisted to;
  isNotNull to;
  allowed_amount <- minterAllowed[initiator];
  match allowed_amount with
  | Some (Some a) =>
    within_limits = uint128_le value a;
    match within_limits with
    | True =>
      new_supply = builtin add value current_supply;
      new_to_bal = builtin add value to_bal;
      new_allowed_amount = builtin sub a value;
      new_option_allowed_amount = let equal_zero = builtin eq zero new_allowed_amount in
        match equal_zero with
        | False => Some {Uint128} new_allowed_amount
        | True => None {Uint128}
        end;
      minterAllowed[initiator] := new_option_allowed_amount;
      e = {_eventname : "Minted"; minter : initiator; amount : value; recipient : to};
      event e;
      msg_to_proxy = {_tag : "mintCallBack"; _recipient : _sender; _amount : zero; to : to; new_to_bal : new_to_bal; new_supply : new_supply};
      msg_to_recipient = {_tag : "RecipientAcceptMint"; _recipient : to; _amount : zero; recipient : to; amount : value};
      msg_to_sender = {_tag : "MintSuccessCallBack"; _recipient : initiator; _amount : zero; recipient : to; amount : value};
      msgs = two_msgs msg_to_proxy msg_to_sender;
      msgs_final = Cons {Message} msg_to_recipient msgs;
      send msgs_final
    | False =>
      err = CodeInsufficientMintAllowance;
      ThrowError err
    end
  | _ =>
    err = CodeNoMintAllowance;
    ThrowError err
  end
end

transition burn(value : Uint128, initiator : ByStr20, initiator_balance : Uint128, current_supply : Uint128)
  isProxy _sender;
  isNotPaused;
  isMinter initiator;
  isNotBlacklisted initiator;
  can_do = uint128_le value initiator_balance;
  match can_do with
  | True =>
    new_burn_balance = builtin sub initiator_balance value;
    new_supply = builtin sub current_supply value;
    msg_to_proxy = {_tag : "burnCallBack"; _recipient : _sender; _amount : zero; initiator : initiator; new_burn_balance : new_burn_balance; new_supply : new_supply};
    msg_to_sender = {_tag : "BurnSuccessCallBack"; _recipient : initiator; _amount : zero; sender : initiator; amount : value};
    msgs = two_msgs msg_to_proxy msg_to_sender;
    e = { _eventname : "Burnt"; burner : initiator; amount : value};
    event e;
    send msgs
  | False =>
    err = CodeInsufficientFunds;
    ThrowError err
  end
end

transition lawEnforcementWipingBurn(address : ByStr20, initiator : ByStr20, addr_bal : Uint128, current_supply : Uint128)
  isProxy _sender;
  isPaused <- paused;
  isBlacklistedAddress <- exists blacklisted[address];
  current_blacklister <- blacklister;
  isBlacklister = builtin eq current_blacklister initiator;
  or_res =
  let isNotBlacklistedAddress = negb isBlacklistedAddress in
  let isNotBlacklister = negb isBlacklister in
    orb_3 isPaused isNotBlacklistedAddress isNotBlacklister;
  match or_res with
  | False =>
      new_supply = builtin sub current_supply addr_bal;
      msg_to_proxy = {_tag : "lawEnforcementWipingBurnCallBack"; _recipient : _sender; _amount : zero; address : address; new_supply : new_supply};
      msg_to_sender = {_tag : "LawEnforcementWipingBurnSuccessCallBack"; _recipient : initiator; _amount : zero; address : address};
      msgs = two_msgs msg_to_proxy msg_to_sender;
      e = { _eventname : "LawEnforcementWipingBurnt"; blacklister : initiator; address : address; amount : addr_bal};
      event e;
      send msgs
  | True =>
    err = CodeNotAuthorized;
    ThrowError err
  end
end
transition increaseAllowance(spender : ByStr20, value : Uint128, initiator : ByStr20)
  isProxy _sender;
  isPaused <- paused;
  isBlacklistedInitiator <- exists blacklisted[initiator];
  isBlacklistedSpender   <- exists blacklisted[spender];
  or_res = orb_3 isPaused isBlacklistedInitiator isBlacklistedSpender;
  match or_res with
  | False =>
    get_current_allowance <- allowed[initiator][spender];
    current_allowance =
      match get_current_allowance with
      | Some allowance => allowance
      | None => zero
      end;
    new_allowance = builtin add current_allowance value;
    allowed[initiator][spender] := new_allowance;
    e = {_eventname : "IncreasedAllowance"; token_owner : initiator; spender : spender; new_allowance : new_allowance};
    event e
  | True =>
    err = CodeNotAuthorized;
    ThrowError err
  end
end
transition decreaseAllowance(spender : ByStr20, value : Uint128, initiator : ByStr20)
  isProxy _sender;
  isPaused <- paused;
  isBlacklistedInitiator <- exists blacklisted[initiator];
  isBlacklistedSpender   <- exists blacklisted[spender];
  or_res = orb_3 isPaused isBlacklistedInitiator isBlacklistedSpender;
  match or_res with
  | False =>
    get_current_allowance <- allowed[initiator][spender];
    current_allowance =
      match get_current_allowance with
      | Some allowance => allowance
      | None => zero
      end;
    new_allowance =
      let value_le_allowance = uint128_le value current_allowance in
      match value_le_allowance with
      | True => builtin sub current_allowance value
      | False => zero
      end;
    allowed[initiator][spender] := new_allowance;
    e = {_eventname : "DecreasedAllowance"; token_owner : initiator; spender : spender; new_allowance : new_allowance};
    event e
  | True =>
    err = CodeNotAuthorized;
    ThrowError err
  end
end
transition transfer(to : ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, init_bal : Uint128)
  isProxy _sender;
  isPaused <- paused;
  isBlacklistedInitiator  <- exists blacklisted[initiator];
  isBlacklistedRecipient  <- exists blacklisted[to];
  isSelf = builtin eq initiator to;
  isNull = builtin eq null_address to;
  or_res = orb_5 isPaused isBlacklistedInitiator isBlacklistedRecipient isSelf isNull;
  match or_res with
  | False =>
    can_do = uint128_le value init_bal;
    match can_do with
    | True =>
      new_init_bal = builtin sub init_bal value;
      new_to_bal = builtin add to_bal value;
      e = {_eventname : "Transfer"; sender : initiator; recipient : to; amount : value};
      event e;
      msg_to_proxy = {_tag : "transferCallBack"; _recipient : _sender; _amount : zero;
            to : to; initiator : initiator; new_to_bal : new_to_bal; new_init_bal : new_init_bal};
      msg_to_sender = {_tag : "TransferSuccessCallBack"; _recipient : initiator; _amount : zero;
            sender : initiator; recipient : to; amount : value};
      msg_to_recipient = {_tag : "RecipientAcceptTransfer"; _recipient : to; _amount : zero;
            sender : initiator; recipient : to; amount : value};
      msgs = two_msgs msg_to_proxy msg_to_sender;
      msgs_final = Cons {Message} msg_to_recipient msgs;
      send msgs_final
    | False =>
      err = CodeInsufficientFunds;
      ThrowError err
    end
  | True =>
    err = CodeNotAuthorized;
    ThrowError err
  end
end
transition transferFrom (from : ByStr20, to : ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, from_bal : Uint128)
  isProxy _sender;
  isPaused <- paused;
  isBlacklistedInitiator <- exists blacklisted[initiator];
  isBlacklistedRecipient <- exists blacklisted[to];
  isBlacklistedFrom <- exists blacklisted[from];
  isSelf = builtin eq from to;
  isNull = builtin eq null_address to;
  or_res = orb_6 isPaused isBlacklistedInitiator isBlacklistedRecipient isBlacklistedFrom isSelf isNull;
  match or_res with
  | False =>
    sender_allowed_from <- allowed[from][initiator];
    match sender_allowed_from with
    | Some allowance =>
      t = min_int from_bal allowance;
      can_do = uint128_le value t;
      match can_do with
      | True =>
        new_from_bal = builtin sub from_bal value;
        new_to_bal = builtin add to_bal value;
        new_allowed = builtin sub allowance value;
        allowed[from][initiator] := new_allowed;
        e = {_eventname : "TransferFromSuccess"; initiator : initiator; sender : from; recipient : to; amount : value};
        event e;
        msg_to_sender = {_tag : "TransferFromSuccessCallBack"; _recipient : initiator; _amount : zero;
                initiator : initiator; sender : from; recipient : to; amount : value };
        msg_to_proxy = {_tag : "transferFromCallBack"; _recipient : _sender; _amount : zero;
                from : from; to : to; new_from_bal : new_from_bal; new_to_bal : new_to_bal };
        msg_to_recipient = {_tag : "RecipientAcceptTransferFrom"; _recipient : to; _amount : zero;
                initiator : initiator; sender : from; recipient : to; amount : value};
        msgs = two_msgs msg_to_proxy msg_to_sender;
        msgs_final = Cons {Message} msg_to_recipient msgs;
        send msgs_final
      | False =>
        err = CodeInsufficientFunds;
        ThrowError err
      end
    | None =>
      err = CodeInsufficientAllowance;
      ThrowError err
    end
  | True =>
    err = CodeNotAuthorized;
    ThrowError err
  end
end
