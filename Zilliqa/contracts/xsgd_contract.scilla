scilla_version 0

import BoolUtils IntUtils ListUtils

library XSGDContract

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end
let orb_3 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) =>
    let t = orb a b in
    orb c t
let orb_4 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) =>
    let t1 = orb a b in
    let t2 = orb t1 c in
    orb t2 d
let orb_5 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) => fun (e : Bool) =>
    let t1 = orb a b in
    let t2 = orb t1 c in
    let t3 = orb t2 d in
    orb t3 e
let one_msg =
    fun (msg : Message) =>
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg
let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp
let f_eq =
  fun (a : ByStr20) =>
  fun (b : ByStr20) =>
    builtin eq a b
let zero = Uint128 0
let one  = Uint128 1
let none_uint128 = None {Uint128}
let true = True
let false = False
(* Error events *)
type Error =
  | CodeNotProxy
  | CodeNotOwner
  | CodeNotPauser
  | CodeNotBlacklister
  | CodeNotMasterMinter
  | CodeInsufficientMintAllowance
  | CodeNoMintAllowance
  | CodeNotAuthorized
  | CodeNotFound
  | CodeInsufficientFunds
  | CodeInsufficientAllowance
let make_error_event =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotProxy                  => Int32 -1
      | CodeNotOwner                  => Int32 -2
      | CodeNotPauser                 => Int32 -3
      | CodeNotBlacklister            => Int32 -4
      | CodeNotMasterMinter           => Int32 -5
      | CodeInsufficientMintAllowance => Int32 -6
      | CodeNoMintAllowance           => Int32 -7
      | CodeNotAuthorized             => Int32 -8
      | CodeNotFound                  => Int32 -9
      | CodeInsufficientFunds         => Int32 -10
      | CodeInsufficientAllowance     => Int32 -11
      end
    in
    { _eventname : "Error"; code : result_code }

contract XSGDContract
(
  name :    String,
  symbol :  String,
  decimals : Uint32,
  init_owner : ByStr20,
  proxy_address : ByStr20
)
with
  let string_is_not_empty =
    fun (s : String) =>
      let zero = Uint32 0 in
      let s_length = builtin strlen s in
      let s_empty = builtin eq s_length zero in
      negb s_empty
  in
  let name_ok = string_is_not_empty name in
  let symbol_ok = string_is_not_empty symbol in
  let name_symbol_ok = andb name_ok symbol_ok in
  let decimals_ok =
    let six = Uint32 6 in
    let eighteen = Uint32 18 in
    let decimals_at_least_6 = uint32_le six decimals in
    let decimals_no_more_than_18 = uint32_le decimals eighteen in
    andb decimals_at_least_6 decimals_no_more_than_18 in
  andb name_symbol_ok decimals_ok
=>

field owner : ByStr20 = init_owner
field pauser : ByStr20 = init_owner
field masterMinter : ByStr20 = init_owner
field paused : Bool = True
field blacklister : ByStr20 = init_owner
field blacklisted : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field minterAllowed : Map ByStr20 (Option Uint128) = Emp ByStr20 (Option Uint128)

procedure ThrowError(err : Error)
  e = make_error_event err;
  event e;
  throw
end
transition transferOwnership(newOwner : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True =>
      owner := newOwner;
      e = {_eventname : "OwnershipTransferred"; from : initiator; to : newOwner};
	    event e
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  end
end
transition pause(initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_pauser <- pauser;
    ispauser = builtin eq current_pauser initiator;
    match ispauser with
    | True  =>
      paused := true;
      e = { _eventname : "Paused"; sender : initiator};
      event e
    | False =>
      err = CodeNotPauser;
      ThrowError err
    end
  end
end
transition unpause(initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_pauser <- pauser;
    ispauser = builtin eq current_pauser initiator;
    match ispauser with
    | True  =>
      paused := false;
      e = {_eventname : "Unpaused"; sender : initiator};
      event e
    | False =>
      err = CodeNotPauser;
      ThrowError err
    end
  end
end
transition updatePauser(newPauser : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True  =>
      pauser := newPauser;
      e = {_eventname : "PauserUpdated"; pauser : newPauser; sender : initiator};
      event e
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  end
end
transition blacklist(address : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_blacklister <- blacklister;
    isBlacklister = builtin eq current_blacklister initiator;
    match isBlacklister with
    | True =>
      blacklisted[address] := one;
      e = {_eventname : "Blacklisted"; address : address; sender : initiator};
      event e
    | False =>
      err = CodeNotBlacklister;
      ThrowError err
    end
  end
end
transition unBlacklist(address : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_blacklister <- blacklister;
    isBlacklister = builtin eq current_blacklister initiator;
    match isBlacklister with
    | True =>
      delete blacklisted[address];
      e = {_eventname : "UnBlacklisted"; address : address; sender : initiator};
      event e
    | False =>
      err = CodeNotBlacklister;
      ThrowError err
    end
  end
end
transition updateBlacklister(newBlacklister : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True =>
      blacklister:= newBlacklister;
      e = {_eventname : "BlacklisterUpdated"; blacklister : newBlacklister; sender : initiator};
      event e
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  end
end
transition updateMasterMinter(newMasterMinter : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True =>
      masterMinter := newMasterMinter;
      e = {_eventname : "MasterMinterUpdated"; masterMinter : newMasterMinter; sender : initiator};
      event e
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  end
end
transition increaseMinterAllowance(minter : ByStr20, amount : Uint128, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    currentMasterMinter <- masterMinter;
    isMasterMinter = builtin eq initiator currentMasterMinter;
    match isMasterMinter with
    | True =>
      get_minter_allowance <- minterAllowed[minter];
      mint_allowance =
        match get_minter_allowance with
        | Some (Some allowance) => allowance
        | _ => zero
        end;
      new_mint_allowance = builtin add mint_allowance amount;
      new_option_mint_allowance = Some {Uint128} new_mint_allowance;
      minterAllowed[minter] := new_option_mint_allowance;
      e = { _eventname : "IncreasedMinterAllowance"; minter : minter; new_mint_allowance : new_mint_allowance; sender : initiator};
      event e
    | False =>
      err = CodeNotMasterMinter;
      ThrowError err
    end
  end
end
transition decreaseMinterAllowance(minter : ByStr20, amount : Uint128, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    currentMasterMinter <- masterMinter;
    isMasterMinter = builtin eq initiator currentMasterMinter;
    match isMasterMinter with
    | True =>
      get_minter_allowance <- minterAllowed[minter];
      mint_allowance =
        match get_minter_allowance with
        | Some (Some allowance) => allowance
        | _ => zero
        end;
      new_option_mint_allowance =
        let amount_le_allowance = uint128_le amount mint_allowance in
        match amount_le_allowance with
        | True =>
            let new_mint_allowance = builtin sub mint_allowance amount in
            let is_zero = builtin eq new_mint_allowance zero in
            match is_zero with
            | False => Some {Uint128} new_mint_allowance
            | True => None {Uint128}
            end
        | False => None {Uint128}
        end;
      minterAllowed[minter] := new_option_mint_allowance;
      e = { _eventname : "DecreasedMinterAllowance"; minter : minter; new_option_mint_allowance : new_option_mint_allowance; sender : initiator};
      event e
    | False =>
      err = CodeNotMasterMinter;
      ThrowError err
    end
  end
end
transition mint(to: ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, current_supply : Uint128)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isMinter <- minterAllowed[initiator];
    isMinterAllowed =
        match isMinter with
        | Some (Some allowance) => True
        | _ => False
        end;
    isBlacklistedMinter <- exists blacklisted[initiator];
    isBlacklistedRecipient <- exists blacklisted[to];
    or_res =
        let isMinterNotAllowed = negb isMinterAllowed in
         orb_4 isPaused isMinterNotAllowed isBlacklistedMinter isBlacklistedRecipient;
    match or_res with
    | False =>
      allowed_amount <- minterAllowed[initiator];
      match allowed_amount with
      | Some (Some a) =>
        within_limits = uint128_le value a;
        match within_limits with
        | True =>
          new_supply = builtin add value current_supply;
          new_to_bal = builtin add value to_bal;
          new_allowed_amount = builtin sub a value;
          new_option_allowed_amount = let equal_zero = builtin eq zero new_allowed_amount in
            match equal_zero with
            | False => Some {Uint128} new_allowed_amount
            | True => None {Uint128}
            end;
          minterAllowed[initiator] := new_option_allowed_amount;
          e = {_eventname : "Minted"; minter : initiator; amount : value; recipient : to};
          event e;
          msg_to_proxy = {_tag : "mintCallBack"; _recipient : _sender; _amount : zero; to : to; new_to_bal : new_to_bal; new_supply : new_supply};
          msg_to_recipient = {_tag : "RecipientAcceptMint"; _recipient : to; _amount : zero; recipient : to; amount : value};
          msg_to_sender = {_tag : "MintSuccessCallBack"; _recipient : initiator; _amount : zero; recipient : to; amount : value};
          msgs = two_msgs msg_to_proxy msg_to_sender;
          msgs_final = Cons {Message} msg_to_recipient msgs;
          send msgs_final
        | False =>
          err = CodeInsufficientMintAllowance;
          ThrowError err
        end
      | _ =>
        err = CodeNoMintAllowance;
        ThrowError err
      end
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
transition burn(value : Uint128, initiator : ByStr20, initiator_balance : Uint128, current_supply : Uint128)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isMinter <- minterAllowed[initiator];
    isMinterAllowed =
        match isMinter with
        | Some (Some allowance) => True
        | _ => False
        end;
    isBlacklistedMinter <- exists blacklisted[initiator];
    or_res =
    let isMinterNotAllowed = negb isMinterAllowed in
      orb_3 isPaused isBlacklistedMinter isMinterNotAllowed;
    match or_res with
    | False =>
      can_do = uint128_le value initiator_balance;
      match can_do with
      | True =>
        new_burn_balance = builtin sub initiator_balance value;
        new_supply = builtin sub current_supply value;
        msg_to_proxy = {_tag : "burnCallBack"; _recipient : _sender; _amount : zero; initiator : initiator; new_burn_balance : new_burn_balance; new_supply : new_supply};
        msg_to_sender = {_tag : "BurnSuccessCallBack"; _recipient : initiator; _amount : zero; sender : initiator; amount : value};
        msgs = two_msgs msg_to_proxy msg_to_sender;
        e = { _eventname : "Burnt"; burner : initiator; amount : value};
        event e;
        send msgs
      | False =>
        err = CodeInsufficientFunds;
        ThrowError err
      end
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
transition lawEnforcementWipingBurn(address : ByStr20, initiator : ByStr20, addr_bal : Uint128, current_supply : Uint128)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isBlacklistedAddress <- exists blacklisted[address];
    current_blacklister <- blacklister;
    isBlacklister = builtin eq current_blacklister initiator;
    or_res =
    let isNotBlacklistedAddress = negb isBlacklistedAddress in
    let isNotBlacklister = negb isBlacklister in
     orb_3 isPaused isNotBlacklistedAddress isNotBlacklister;
    match or_res with
    | False =>
        new_supply = builtin sub current_supply addr_bal;
        msg_to_proxy = {_tag : "lawEnforcementWipingBurnCallBack"; _recipient : _sender; _amount : zero; address : address; new_supply : new_supply};
        msg_to_sender = {_tag : "LawEnforcementWipingBurnSuccessCallBack"; _recipient : initiator; _amount : zero; address : address};
        msgs = two_msgs msg_to_proxy msg_to_sender;
        e = { _eventname : "LawEnforcementWipingBurnt"; blacklister : initiator; address : address; amount : addr_bal};
        event e;
        send msgs
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
transition increaseAllowance(spender : ByStr20, value : Uint128, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isBlacklistedInitiator <- exists blacklisted[initiator];
    isBlacklistedSpender   <- exists blacklisted[spender];
    or_res = orb_3 isPaused isBlacklistedInitiator isBlacklistedSpender;
    match or_res with
    | False =>
      get_current_allowance <- allowed[initiator][spender];
      current_allowance =
        match get_current_allowance with
        | Some allowance => allowance
        | None => zero
        end;
      new_allowance = builtin add current_allowance value;
      allowed[initiator][spender] := new_allowance;
      e = {_eventname : "IncreasedAllowance"; sender : initiator; spender : spender; new_allowance : new_allowance};
      event e
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
transition decreaseAllowance(spender : ByStr20, value : Uint128, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isBlacklistedInitiator <- exists blacklisted[initiator];
    isBlacklistedSpender   <- exists blacklisted[spender];
    or_res = orb_3 isPaused isBlacklistedInitiator isBlacklistedSpender;
    match or_res with
    | False =>
      get_current_allowance <- allowed[initiator][spender];
      current_allowance =
        match get_current_allowance with
        | Some allowance => allowance
        | None => zero
        end;
      new_allowance =
        let value_le_allowance = uint128_le value current_allowance in
        match value_le_allowance with
        | True => builtin sub current_allowance value
        | False => zero
        end;
      allowed[initiator][spender] := new_allowance;
      e = {_eventname : "DecreasedAllowance"; sender : initiator; spender : spender; new_allowance : new_allowance};
      event e
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
transition transfer(to : ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, init_bal : Uint128)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
      err = CodeNotProxy;
      ThrowError err
    | True  =>
      isPaused <- paused;
      isBlacklistedInitiator  <- exists blacklisted[initiator];
      isBlacklistedRecipient  <- exists blacklisted[to];
      isSelf = builtin eq to initiator;
      or_res = orb_4 isPaused isBlacklistedInitiator isBlacklistedRecipient isSelf;
      match or_res with
      | False =>
        can_do = uint128_le value init_bal;
        match can_do with
        | True =>
          new_init_bal = builtin sub init_bal value;
          new_to_bal = builtin add to_bal value;
          e = {_eventname : "Transfer"; sender : initiator; recipient : to; amount : value};
          event e;
          msg_to_proxy = {_tag : "transferCallBack"; _recipient : _sender; _amount : zero;
                to : to; initiator : initiator; new_to_bal : new_to_bal; new_init_bal : new_init_bal};
          msg_to_sender = {_tag : "TransferSuccessCallBack"; _recipient : initiator; _amount : zero;
                sender : initiator; recipient : to; amount : value};
          msg_to_recipient = {_tag : "RecipientAcceptTransfer"; _recipient : to; _amount : zero;
                                sender : initiator; recipient : to; amount : value};
          msgs = two_msgs msg_to_proxy msg_to_sender;
          msgs_final = Cons {Message} msg_to_recipient msgs;
          send msgs_final
        | False =>
          err = CodeInsufficientFunds;
          ThrowError err
        end
      | True =>
        err = CodeNotAuthorized;
        ThrowError err
      end
   end
end
transition transferFrom (from : ByStr20, to : ByStr20, value : Uint128, initiator : ByStr20, to_bal : Uint128, from_bal : Uint128)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
    err = CodeNotProxy;
    ThrowError err
  | True  =>
    isPaused <- paused;
    isBlacklistedInitiator <- exists blacklisted[initiator];
    isBlacklistedRecipient <- exists blacklisted[to];
    isBlacklistedFrom <- exists blacklisted[from];
    isSelf = builtin eq from to;
    or_res = orb_5 isPaused isBlacklistedInitiator isBlacklistedRecipient isBlacklistedFrom isSelf;
    match or_res with
    | False =>
      sender_allowed_from <- allowed[from][initiator];
      match sender_allowed_from with
      | Some allowance =>
        t = min_int from_bal allowance;
        can_do = uint128_le value t;
        match can_do with
        | True =>
          new_from_bal = builtin sub from_bal value;
          new_to_bal = builtin add to_bal value;
          new_allowed = builtin sub allowance value;
          allowed[from][initiator] := new_allowed;
          e = {_eventname : "TransferFromSuccess"; recipient : to; sender : from; initiator : initiator; amount : value};
          event e;
          msg_to_sender = {_tag : "TransferFromSuccessCallBack"; _recipient : initiator; _amount : zero;
                  sender : from; recipient : to; amount : value };
          msg_to_proxy = {_tag : "transferFromCallBack"; _recipient : _sender; _amount : zero;
                  from : from; to : to; new_from_bal : new_from_bal; new_to_bal : new_to_bal };
          msg_to_recipient = {_tag : "RecipientAcceptTransferFrom"; _recipient : to; _amount : zero;
                                sender : from; recipient : to; amount : value};
          msgs = two_msgs msg_to_proxy msg_to_sender;
          msgs_final = Cons {Message} msg_to_recipient msgs;
          send msgs_final
        | False =>
          err = CodeInsufficientFunds;
          ThrowError err
        end
      | None =>
        err = CodeInsufficientAllowance;
        ThrowError err
	    end
    | True =>
      err = CodeNotAuthorized;
      ThrowError err
    end
  end
end
