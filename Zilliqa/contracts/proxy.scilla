scilla_version 0

(* Proxy contract to be used by Xfers *)

import BoolUtils IntUtils

library ProxyContract

let zero = Uint128 0

(* returns singleton List Message *)
let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

(* Error events *)
type Error =
  | CodeNotAdmin
  | CodeNotCurrImpl
let make_error_event =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAdmin                  => Int32 -1
      | CodeNotCurrImpl               => Int32 -2
      end
    in
    { _eventname : "Error"; code : result_code }


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ProxyContract
(
init_implementation : ByStr20,
init_admin : ByStr20
)

field implementation : ByStr20 = init_implementation
field admin : ByStr20 = init_admin
field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field totalSupply : Uint128 = zero

(* Internal functions, used like Solidity modifiers *)
procedure ThrowError(err : Error)
  e = make_error_event err;
  event e;
  throw
end

procedure isAdmin(address: ByStr20)
  current_admin <- admin;
  is_admin = builtin eq current_admin address;
  match is_admin with
  (* if True, continue *)
  | True =>
  (* if False, throw error *)
  | False =>
    err = CodeNotAdmin;
    ThrowError err
  end
end

procedure isCurrImpl(address: ByStr20)
  current_impl <- implementation;
  is_curr_imp = builtin eq current_impl address;
  match is_curr_imp with
  | True => 
  | False =>
    err = CodeNotCurrImpl;
    ThrowError err
  end
end

transition UpgradeTo(newImplementation : ByStr20)
  (* Conditional checks *)
  isAdmin _sender;

  (* Update state and emits event *)
  implementation := newImplementation;
  e = {_eventname : "Upgraded"; implementation_address : newImplementation};
  event e
end

transition ChangeAdmin(newAdmin : ByStr20)
  (* Conditional checks *)
  isAdmin _sender;

  (* Update state and emits event *)
  currentAdmin <- admin;
  admin := newAdmin;
  e = {_eventname : "AdminChanged"; oldAdmin : currentAdmin; newAdmin : newAdmin};
  event e
end

transition TransferOwnership(newOwner : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "transferOwnership"; _recipient : current_impl; _amount : zero;
          newOwner : newOwner; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition Pause()
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "pause"; _recipient : current_impl; _amount : zero; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition UnPause()
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "unpause"; _recipient : current_impl; _amount : zero; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition UpdatePauser(newPauser : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "updatePauser"; _recipient : current_impl; _amount : zero;
          newPauser : newPauser; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition Blacklist(address : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "blacklist"; _recipient : current_impl; _amount : zero;
          address : address; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition UnBlacklist(address : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "unBlacklist"; _recipient : current_impl; _amount : zero;
          address : address; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition UpdateBlacklister(newBlacklister : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "updateBlacklister"; _recipient : current_impl; _amount : zero;
          newBlacklister : newBlacklister; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition Mint(recipient: ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  current_supply <- totalSupply;
  get_to_bal <- balances[recipient];
  to_bal =
    match get_to_bal with
    | Some bal => bal
    | None => zero
    end;
  msg = {_tag : "mint"; _recipient : current_impl; _amount : zero; to : recipient;
          value : amount; initiator : _sender; to_bal : to_bal; current_supply : current_supply};
  msgs = one_msg msg;
  send msgs
end

transition mintCallBack(to: ByStr20, new_to_bal: Uint128, new_supply : Uint128)
    current_impt <- implementation;
    is_current_imp = builtin eq current_impt _sender;
    match is_current_imp with
    | False =>
        throw
    | True =>
        balances[to] := new_to_bal;
        totalSupply := new_supply
    end
end

transition IncreaseAllowance (spender : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "increaseAllowance"; _recipient : current_impl; _amount : zero;
          spender : spender; value : amount; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition DecreaseAllowance (spender : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "decreaseAllowance"; _recipient : current_impl; _amount : zero;
          spender : spender; value : amount; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition TransferFrom (from : ByStr20, to : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  get_to_bal <- balances[to];
  to_bal =
      match get_to_bal with
      | Some bal => bal
      | None => zero
      end;
  get_from_bal <- balances[from];
  from_bal =
      match get_from_bal with
      | Some bal => bal
      | None => zero
      end;
  msg = {_tag : "transferFrom"; _recipient : current_impl; _amount : zero;
          from : from; to : to; value : amount; initiator : _sender; to_bal : to_bal; from_bal : from_bal};
  msgs = one_msg msg;
  send msgs
end

transition transferFromCallBack(from : ByStr20, to : ByStr20, new_from_bal : Uint128, new_to_bal : Uint128)
    current_impt <- implementation;
    is_current_imp = builtin eq current_impt _sender;
    match is_current_imp with
    | False =>
        throw
    | True =>
        balances[to] := new_to_bal;
        balances[from] := new_from_bal
    end
end

transition Transfer (to : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  get_to_bal <- balances[to];
  to_bal =
      match get_to_bal with
      | Some bal => bal
      | None => zero
      end;
  get_init_bal <- balances[_sender];
  init_bal =
      match get_init_bal with
      | Some bal => bal
      | None => zero
      end;
  msg = {_tag : "transfer"; _recipient : current_impl; _amount : zero; to : to;
          value : amount; initiator : _sender; to_bal : to_bal; init_bal : init_bal};
  msgs = one_msg msg;
  send msgs
end

transition transferCallBack(to : ByStr20, initiator : ByStr20, new_to_bal : Uint128, new_init_bal : Uint128)
    current_impt <- implementation;
    is_current_imp = builtin eq current_impt _sender;
    match is_current_imp with
    | False =>
        throw
    | True =>
        balances[to] := new_to_bal;
        balances[initiator] := new_init_bal
    end
end

transition Burn(amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  current_supply <- totalSupply;
  get_burn_bal <- balances[_sender];
  burn_bal =
      match get_burn_bal with
      | Some bal => bal
      | None => zero
      end;
  msg = {_tag : "burn"; _recipient : current_impl; _amount : zero; value : amount; initiator : _sender; initiator_balance : burn_bal; current_supply : current_supply};
  msgs = one_msg msg;
  send msgs
end

transition burnCallBack(initiator : ByStr20, new_burn_balance : Uint128, new_supply : Uint128)
    current_impt <- implementation;
    is_current_imp = builtin eq current_impt _sender;
    match is_current_imp with
    | False =>
        throw
    | True =>
        balances[initiator] := new_burn_balance;
        totalSupply := new_supply
    end
end

transition LawEnforcementWipingBurn(address : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  current_supply <- totalSupply;
  get_addr_bal <- balances[address];
  addr_bal =
      match get_addr_bal with
      | Some bal => bal
      | None => zero
      end;
  msg = {_tag : "lawEnforcementWipingBurn"; _recipient : current_impl; _amount : zero; address : address; initiator : _sender; addr_bal : addr_bal; current_supply : current_supply};
  msgs = one_msg msg;
  send msgs
end

transition lawEnforcementWipingBurnCallBack(address : ByStr20, new_supply : Uint128)
    current_impt <- implementation;
    is_current_imp = builtin eq current_impt _sender;
    match is_current_imp with
    | False =>
        throw
    | True =>
        balances[address] := zero;
        totalSupply := new_supply
    end
end

transition IncreaseMinterAllowance(minter : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "increaseMinterAllowance"; _recipient : current_impl; _amount : zero; minter : minter;
          amount : amount; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition DecreaseMinterAllowance(minter : ByStr20, amount : Uint128)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "decreaseMinterAllowance"; _recipient : current_impl; _amount : zero; minter : minter;
          amount : amount; initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

transition UpdateMasterMinter(newMasterMinter : ByStr20)
  (* Creates message to be called on the implementation contract *)
  current_impl <- implementation;
  msg = {_tag : "updateMasterMinter"; _recipient : current_impl; _amount : zero; newMasterMinter : newMasterMinter;
          initiator : _sender};
  msgs = one_msg msg;
  send msgs
end

