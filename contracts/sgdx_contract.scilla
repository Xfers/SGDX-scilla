scilla_version 0

(* SGDXContract to be used by Xfers to represent fiat-backed stablecoin *)

import BoolUtils IntUtils ListUtils

library SGDXContract 

let orb_3 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) =>
    let t = orb a b in
    orb c t

let orb_4 =
  fun (a : Bool) => fun (b : Bool) => fun (c : Bool) => fun (d : Bool) =>
    let t1 = orb a b in
    let t2 = orb t1 c in
    orb t2 d

(* returns singleton List Message *)
let one_msg =
    fun (msg : Message) =>
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg

(* A util function to test equality *)
let f_eq =
  fun (a : ByStr20) =>
  fun (b : ByStr20) =>
    builtin eq a b

(* Instantiate a type function to test membership in a list *)
let isDefaultOperator = @list_mem ByStr20

(* Simple global constants *)
let zero = Uint128 0
let one  = Uint128 1
let true = True
let false = False

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SGDXContract 
(
  name :    String,
  symbol :  String,
  currency : String,
  decimals : Uint32,
  init_owner : ByStr20,
  default_operators : List ByStr20,
  proxy_address : ByStr20
)


field owner : ByStr20 = init_owner
field pauser : ByStr20 = init_owner 
field masterMinter : ByStr20 = init_owner
field paused : Bool = False
field blacklister : ByStr20 = init_owner
field blacklisted : Map ByStr20 Uint128 = Emp ByStr20 Uint128

field revokedDefaultOperators : Map ByStr20 (Map ByStr20 Bool) = Emp ByStr20 (Map ByStr20 Bool)

field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)    
field totalSupply : Uint128  = zero
field minters : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field minterAllowed : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* Re-authorize a default operator for an initiator *)
transition reauthorizeDefaultOperator(operator : ByStr20, initiator : ByStr20)  
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  => 
    isDefaultOperator = isDefaultOperator f_eq operator default_operators;
    match isDefaultOperator with
    | True  => 
      delete revokedDefaultOperators[initiator][operator];
      e = { _eventname : "ReAuthorizedDefaultOperator"; operator : operator; sender : initiator};
      event e
    | False =>
    end
  end
end

(* Revoke a default operator for an initiator *)
transition revokeDefaultOperator(operator : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    isDefaultOperator =  isDefaultOperator f_eq operator default_operators;
    match isDefaultOperator with
    | True  => 
      revokedDefaultOperators[initiator][operator] := true;
      e = {_eventname : "RevokedDefaultOperator"; operator : operator; sender : initiator};
      event e
    | False =>
    end
  end
end

(* Allows the current owner to transfer control of the contract to a newOwner *)
transition transferOwnership(newOwner : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True =>
      owner := newOwner;
      e = {_eventname : "OwnershipTransferred"; from : initiator; to : newOwner};
	    event e 
    | False =>
    end
  end
end 

(* Pause the contract to temporarily stop all transfer of tokens. *)
(* Other housekeeping transitions can still be invoked. *)
(* Only the current pauser can invoke this transition. *)
transition pause(initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_pauser <- pauser;
    ispauser = builtin eq current_pauser initiator;
    match ispauser with
    | True  =>
      paused := true;
      e = { _eventname : "Paused"};
      event e
    | False =>
    end
  end
end

(* Unpause the contract to reallow transfer of tokens. *)
(* Only the current pauser can invoke this transition. *)
transition unpause(initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_pauser <- pauser;
    ispauser = builtin eq current_pauser initiator;
    match ispauser with
    | True  =>
      paused := false;   
      e = {_eventname : "Unpaused"};
      event e
    | False =>
    end
  end
end

(* Replace the current pauser with the newPauser *)
(* Only the current owner can invoke this transition *)
transition updatePauser(newPauser : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True  =>  
      pauser := newPauser;
      e = {_eventname : "PauserUpdated"; pauser : newPauser};  
      event e
    | False => 
    end
  end   
end

(* Blacklist a given address. Only the current blacklister can invoke this transition. *)
(* A blacklisted address can neither send or receive tokens. *)
transition blacklist(address : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_blacklister <- blacklister;
    isblacklister = builtin eq current_blacklister initiator;
    match isblacklister with 
    | True =>
      blacklisted[address] := one;
      e = {_eventname : "Blacklisted"; address : address};  
      event e
    | False => 
    end
  end 
end

(* Remove a given address from the blacklist. *) 
(* Only the current blacklister can invoke this transition. *)
transition unBlacklist(address : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    current_blacklister <- blacklister;
    isblacklister = builtin eq current_blacklister initiator;
    match isblacklister with 
    | True =>
      delete blacklisted[address];
      e = {_eventname : "UnBlacklisted"; address : address};  
      event e
    | False => 
    end
  end 
end

(* Replace the current blacklister with the newBlacklister *)
(* Only the current owner can invoke this transition *)
transition updateBlacklister(newBlacklister : ByStr20, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True =>
    current_owner <- owner;
    isowner = builtin eq initiator current_owner;
    match isowner with
    | True =>
      blacklister:= newBlacklister;
      e = {_eventname : "BlacklisterUpdated"; blacklister : newBlacklister};  
      event e
    | False =>
    end
  end 
end

(* Mint new amount number of tokens and allocated them to the to address. *)
(* Only the current minter can invoke this transition. *)
(* Minting can only be done when the contract is not paused. *)
transition mint(to: ByStr20, amount : Uint128, initiator : ByStr20)
  callerIsProxy = builtin eq _sender proxy_address;
  match callerIsProxy with
  | False =>
  | True  =>
    isPaused <- paused;
    isblacklistedinitiator <- exists blacklisted[_sender];
    isblacklisted_receipient <- exists blacklisted[to];
    isMinter <- exists minters[initiator];
    or_res =
        let isNotMinter = negb isMinter in
         orb_4 isPaused isblacklistedinitiator isblacklisted_receipient isNotMinter;
 
    match or_res with   
    | False =>
      allowed_amount <- minterAllowed[initiator];
      match allowed_amount with
      | Some a => 
        within_limits = uint128_le amount a;
        match within_limits with
        | True =>
          t <- totalSupply;
          new_tokens = builtin add amount t;
          totalSupply := new_tokens;
          x <- balances[to];
          current_val = match x with
                        | Some v => v 
                        | None => zero
                        end;        
          new_bal = builtin add amount current_val;
          balances[to] := new_bal;
          new_allowed_amount = builtin sub a amount;
          minterAllowed[initiator] := new_allowed_amount;
          e1 = { _eventname : "Mint"; minter : initiator; amount : amount; recipient : to};
          event e1; 
        | False =>
        end
      | None => 
      end
    | True =>      
    end
  end
end

transition approve (spender : ByStr20, value : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True =>
      isPaused <- paused;
      isblacklistedinitiator <- exists blacklisted[_sender];
      isblacklisted_spender <- exists blacklisted[spender];
      or_res = orb_3 isPaused isblacklistedinitiator isblacklisted_spender;
      match or_res with
      | False =>
        allowed[initiator][spender] := value;
        e = {_eventname : "Approval"; sender : initiator; spender : spender; amount : value};
        event e;
        msg = {_tag : "ApproveSuccess"; _recipient : initiator; _amount : zero;
               approver : initiator; spender : spender; amount : value };
        msgs = one_msg msg;
        send msgs
      | True => 
      end
    end
end

transition operatorSend (from : ByStr20, to : ByStr20, value : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True =>
      isPaused <- paused;
      isblacklistedinitiator <- exists blacklisted[_sender];   
      isblacklisted_receipient <- exists blacklisted[to];
      isblacklisted_from <- exists blacklisted[from];
      or_res = orb_4 isPaused isblacklistedinitiator isblacklisted_receipient isblacklisted_from;
      match or_res with
      | True =>  
      | False => 
        bal <- balances[from];
        isHolder = builtin eq initiator from; 
        isDefaultOperator =  isDefaultOperator f_eq initiator default_operators;
        isRevokedOperator <- exists revokedDefaultOperators[from][initiator];
        isAllowedDefaultOperator = let isNotRevokedOperator = negb isRevokedOperator in andb  isNotRevokedOperator isDefaultOperator;
        isallowed =  orb isHolder isAllowedDefaultOperator;
        match isallowed with
        | False =>
        | True  =>
          match bal with
          | Some b =>
            can_do = uint128_le value b;
            match can_do with
            | True =>
              (* subtract tokens from from and add it to "to" *)
              new_from_bal = builtin sub b value;
              balances[from] := new_from_bal;
        
              (* Adds tokens to "to" address *)
              to_bal <- balances[to];
              new_to_bal = match to_bal with
              | Some x => builtin add x value
              | None => value
              end;
              balances[to] := new_to_bal;
              msg = { _tag : "operatorSendSuccess"; _recipient : initiator; _amount : zero;
                      operator : initiator; from : from; recipient : to; amount : value};
              msgs = one_msg msg;
              send msgs
            | False =>
             (* balance not sufficient. *)
             msg = {_tag : "operatorSendFailure"; _recipient : initiator; _amount : zero;
                    operator : initiator; from : from;  recipient : to; amount : zero};
             msgs = one_msg msg;
             send msgs
            end
          | None =>
            (* no balance record, can't transfer *)
            msg = {_tag : "operatorSendFailure"; _recipient : initiator; _amount : zero;
                  operator : initiator; from : from; sender : _sender; recipient : to; amount : zero};
            msgs = one_msg msg;
            send msgs
          end
        end
     end
  end
end

transition transferFrom (from : ByStr20, to : ByStr20, value : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True =>
      isPaused <- paused;
      isblacklistedinitiator <- exists blacklisted[_sender];   
      isblacklisted_receipient <- exists blacklisted[to];
      isblacklisted_from <- exists blacklisted[from];
      or_res = orb_4 isPaused isblacklistedinitiator isblacklisted_receipient isblacklisted_from;
      match or_res with
      | False => 
        bal <- balances[from];
        (* Check if initiator has been authorized by "from" *)
        sender_allowed_from <- allowed[from][initiator];
        match bal with
        | Some a =>
          match sender_allowed_from with
          | Some b =>
          (* We can only transfer the minimum of available or authorized tokens *)
            can_do = uint128_le value b;
            match can_do with
            | True =>
              (* tokens is what we should subtract from "from" and add to "to" *)
              new_from_bal = builtin sub a value;
              balances[from] := new_from_bal;
              to_bal <- balances[to];
              match to_bal with
              | Some tb =>
                new_to_bal = builtin add tb value;
                balances[to] := new_to_bal
              | None =>
                (* "to" has no balance. So just set it to tokens *)
                balances[to] := value
              end;
              (* reduce "allowed" by "tokens" *)
              new_allowed = builtin sub b value;
              allowed[from][initiator] := new_allowed;
              msg = {_tag : "TransferFromSuccess"; _recipient : initiator; _amount : zero;
                     sender : from; recipient : to; amount : value };
              msgs = one_msg msg;
              send msgs
            | False =>
              msg = {_tag : "TransferFromFailure"; _recipient : initiator; _amount : zero;
                     sender : from; recipient : to; amount : zero };
              msgs = one_msg msg;
              send msgs
            end
          | None =>
            msg = {_tag : "TransferFromFailure"; _recipient : initiator; _amount : zero;
                   sender : from; recipient : to; amount : zero };
            msgs = one_msg msg;
            send msgs
          end
        | None =>
	      msg = {_tag : "TransferFromFailure"; _recipient : initiator; _amount : zero;
                 sender : from; recipient : to; amount : zero };
          msgs = one_msg msg;
          send msgs
        end
      | True => 
      end
   end
end

transition transfer (to : ByStr20, value : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True =>
      isPaused <- paused;
      isblacklisted_initiator <- exists blacklisted[initiator];   
      isblacklisted_receipient <- exists blacklisted[to];
      or_res = orb_3 isPaused isblacklisted_initiator isblacklisted_receipient;
      match or_res with
      | False => 
        bal <- balances[initiator];
        match bal with
        | Some b =>
          can_do = uint128_le value b;
          match can_do with
          | True =>
            (* subtract tokens from initiator and add it to "to" *)
            new_initiator_bal = builtin sub b value;
            balances[initiator] := new_initiator_bal;

            (* Adds tokens to "to" address *)
            to_bal <- balances[to];
            new_to_bal = match to_bal with
                | Some x => builtin add x value
                | None => value
            end;

            balances[to] := new_to_bal;
            msg = {_tag : "TransferSuccess"; _recipient : initiator; _amount : zero;
                   sender : initiator; recipient : to; amount : value};
            msgs = one_msg msg;
            send msgs
          | False =>
            (* balance not sufficient. *)
            msg = {_tag : "TransferFailure"; _recipient : initiator; _amount : zero;
                   sender : initiator; recipient : to; amount : zero};
            msgs = one_msg msg;
            send msgs
          end
        | None =>
         (* no balance record, can't transfer *)
          msg = {_tag : "TransferFailure"; _recipient : initiator; _amount : zero;
                 sender : initiator; recipient : to; amount : zero};
          msgs = one_msg msg;
          send msgs
        end
      | True =>
      end
   end
end

transition burn(value : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True  =>
      isPaused <- paused;
      isMinter <- exists minters[initiator];
      isblacklistedinitiator <- exists blacklisted[_sender];    
      or_res =
      let isNotMinter = negb isMinter in
      orb_3 isPaused isblacklistedinitiator isNotMinter;

      match or_res with 
      | False => 
        bal <- balances[initiator];
        match bal with
        | Some b =>
          can_do = uint128_le value b;
          match can_do with
          | True=>
            new_balance = builtin sub b value;
            balances[initiator] := new_balance;    
            currentSupply <- totalSupply;
            new_supply = builtin sub currentSupply value;
            totalSupply := new_supply;         
            e = { _eventname : "Burn"; burner : initiator; amount : value};
            event e      
          | False =>      
          end
        | None =>
        end    
      | True =>
      end
   end
end

transition configureMinter(minter : ByStr20, minterAllowedAmount : Uint128, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True  =>
      isPaused <- paused;
      currentMasterMinter <- masterMinter;
      isMasterMinter = builtin eq initiator currentMasterMinter;
      or_res = let tmp = negb isMasterMinter in orb isPaused tmp;
      match or_res with
      | False =>
        minters[minter] := one;
        minterAllowed[minter] := minterAllowedAmount;
        e = { _eventname : "MinterConfigured"; minter : minter; amount : minterAllowedAmount};
        event e
      | True =>
      end
   end  
end

transition removeMinter(minter : ByStr20, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True  =>
      currentMasterMinter <- masterMinter;
      isMasterMinter = builtin eq initiator currentMasterMinter;
      match isMasterMinter with
      | True => 
        delete minters[minter];
        minterAllowed[minter] := zero;
        e = { _eventname : "MinterRemoved"; minter : minter};
        event e
      | False =>
      end
   end
end

transition updateMasterMinter(newMasterMinter : ByStr20, initiator : ByStr20)
    callerIsProxy = builtin eq _sender proxy_address;
    match callerIsProxy with
    | False =>
    | True  =>
      current_owner <- owner;
      isowner = builtin eq initiator current_owner;
      match isowner with
      | True =>
        masterMinter := newMasterMinter;
        e = {_eventname : "MasterMinterChanged"; masterMinter : newMasterMinter};  
        event e
      | False =>
      end
    end 
end
